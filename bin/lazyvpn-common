#!/bin/bash

# LazyVPN Common Functions Library (systemd-networkd version)
# Source this file in all lazyvpn scripts

# Error handling functions
error() {
    echo "Error: $*" >&2
    exit 1
}

warn() {
    echo "Warning: $*" >&2
}

info() {
    echo "$*"
}

# Send notification (dismisses old LazyVPN notifications first to avoid spam)
notify() {
    omarchy-notification-dismiss "LazyVPN" 2>/dev/null || true
    notify-send "LazyVPN" "$1"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Provider Definitions (Single Source of Truth)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Display names for UI
declare -A PROVIDER_DISPLAY=(
    [protonvpn]="ProtonVPN"
    [mullvad]="Mullvad"
    [ivpn]="IVPN"
    [pia]="Private Internet Access"
    [nordvpn]="NordVPN"
    [surfshark]="Surfshark"
    [windscribe]="Windscribe"
)

# Short prefixes for filenames (e.g., Proton-US-NY#1.conf)
declare -A PROVIDER_PREFIX=(
    [protonvpn]="Proton"
    [mullvad]="Mullvad"
    [ivpn]="IVPN"
    [pia]="PIA"
    [nordvpn]="Nord"
    [surfshark]="Surf"
    [windscribe]="Windscribe"
)

# Default DNS servers per provider
declare -A PROVIDER_DNS=(
    [protonvpn]="10.2.0.1"
    [mullvad]="10.64.0.1"
    [ivpn]="172.16.0.1"
    [pia]="10.0.0.241"
    [nordvpn]="103.86.96.100"
    [surfshark]="162.252.172.57"
    [windscribe]="10.255.255.1"
)

# Default WireGuard ports per provider
declare -A PROVIDER_PORT=(
    [protonvpn]="51820"
    [mullvad]="51820"
    [ivpn]="2049"
    [pia]="1337"
    [nordvpn]="51820"
    [surfshark]="51820"
    [windscribe]="443"
)

# Gluetun provider name mappings (gluetun uses different identifiers)
declare -A GLUETUN_PROVIDER_MAP=(
    [protonvpn]="protonvpn"
    [mullvad]="mullvad"
    [ivpn]="ivpn"
    [pia]="private internet access"
    [nordvpn]="nordvpn"
    [surfshark]="surfshark"
    [windscribe]="windscribe"
)

# Detect VPN provider from a WireGuard config file
# Returns the internal provider ID (e.g., "protonvpn", "mullvad")
# Usage: provider=$(detect_provider "/path/to/config.conf")
detect_provider() {
    local config_file="$1"
    local provider=""

    # Method 1: DNS server detection (most reliable)
    local dns
    dns=$(grep -i "^DNS" "$config_file" | head -n1 | sed 's/^[^=]*=\s*//' | sed 's/\s*#.*//' | tr -d '\r')
    debug_log provider "detect_provider: DNS value='$dns' from $config_file"

    case "$dns" in
        10.2.0.1) provider="protonvpn" ;;
        10.64.0.1|193.138.218.74) provider="mullvad" ;;
        172.16.0.1) provider="ivpn" ;;
        10.0.0.241|10.0.0.242|10.0.0.243) provider="pia" ;;
        103.86.96.100) provider="nordvpn" ;;
        10.255.255.1) provider="windscribe" ;;
    esac

    if [[ -n "$provider" ]]; then
        debug_log provider "detect_provider: matched via DNS â†’ $provider"
    fi

    # Method 2: Endpoint domain detection
    if [[ -z "$provider" ]]; then
        local endpoint
        endpoint=$(grep -i "^Endpoint" "$config_file" | head -n1 | sed 's/^[^=]*=\s*//' | sed 's/\s*#.*//' | tr -d '\r')
        debug_log provider "detect_provider: Endpoint value='$endpoint'"

        if [[ "$endpoint" =~ protonvpn\.com|protonvpn\.net ]]; then
            provider="protonvpn"
        elif [[ "$endpoint" =~ mullvad\.net ]]; then
            provider="mullvad"
        elif [[ "$endpoint" =~ ivpn\.net ]]; then
            provider="ivpn"
        elif [[ "$endpoint" =~ privateinternetaccess\.com ]]; then
            provider="pia"
        elif [[ "$endpoint" =~ nordvpn\.com ]]; then
            provider="nordvpn"
        elif [[ "$endpoint" =~ surfshark\.com ]]; then
            provider="surfshark"
        elif [[ "$endpoint" =~ windscribe\.com ]]; then
            provider="windscribe"
        fi

        if [[ -n "$provider" ]]; then
            debug_log provider "detect_provider: matched via endpoint â†’ $provider"
        fi
    fi

    # Method 3: Config file comments
    if [[ -z "$provider" ]]; then
        debug_log provider "detect_provider: falling back to comment detection"
        if grep -qi "protonvpn" "$config_file"; then
            provider="protonvpn"
        elif grep -qi "mullvad" "$config_file"; then
            provider="mullvad"
        elif grep -qi "ivpn" "$config_file"; then
            provider="ivpn"
        elif grep -qi "nordvpn" "$config_file"; then
            provider="nordvpn"
        elif grep -qi "surfshark" "$config_file"; then
            provider="surfshark"
        fi

        if [[ -n "$provider" ]]; then
            debug_log provider "detect_provider: matched via comments â†’ $provider"
        else
            debug_log provider "detect_provider: no provider detected"
        fi
    fi

    echo "$provider"
}

# Detect provider from a server filename prefix
# Returns display name (e.g., "ProtonVPN", "Mullvad")
# Usage: provider_name=$(detect_provider_from_name "Proton-US-NY#1")
detect_provider_from_name() {
    local server_name="$1"

    if [[ "$server_name" =~ ^(Proton|proton)- ]]; then
        echo "ProtonVPN"
    elif [[ "$server_name" =~ ^(Mullvad|mullvad)- ]]; then
        echo "Mullvad"
    elif [[ "$server_name" =~ ^(IVPN|ivpn)- ]]; then
        echo "IVPN"
    elif [[ "$server_name" =~ ^(PIA|pia)- ]]; then
        echo "PIA"
    elif [[ "$server_name" =~ ^(Nord|nord|nordvpn)- ]]; then
        echo "NordVPN"
    elif [[ "$server_name" =~ ^(Surf|surf|surfshark)- ]]; then
        echo "Surfshark"
    elif [[ "$server_name" =~ ^(Windscribe|windscribe)- ]]; then
        echo "Windscribe"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Validate config file exists and is readable
validate_config() {
    local config_file="$1"

    # Check if config exists
    if [[ ! -f "$config_file" ]]; then
        return 1
    fi

    # Check if config is readable and has required fields
    if ! grep -q "^CONNECTION_NAME=" "$config_file" 2>/dev/null; then
        return 1
    fi

    # Check if file is valid bash syntax
    if ! bash -n "$config_file" 2>/dev/null; then
        return 1
    fi

    return 0
}

# Atomic config update
atomic_config_update() {
    local key="$1"
    local value="$2"
    local config_file="$3"

    # Validate inputs
    if [[ -z "$key" ]] || [[ -z "$config_file" ]]; then
        warn "atomic_config_update requires key and config_file"
        return 1
    fi

    # Create updated config in temp file
    if [[ -f "$config_file" ]]; then
        # Check if key exists, update or append
        if grep -q "^${key}=" "$config_file" 2>/dev/null; then
            # Update existing line
            if ! sed "s|^${key}=.*|${key}=${value}|" "$config_file" > "${config_file}.tmp"; then
                warn "Failed to update config (sed failed)"
                secure_delete "${config_file}.tmp"
                return 1
            fi
        else
            # Key doesn't exist, append it
            cp "$config_file" "${config_file}.tmp" || return 1
            echo "${key}=${value}" >> "${config_file}.tmp"
        fi
    else
        # Create new config with just this key
        echo "${key}=${value}" > "${config_file}.tmp"
    fi

    # Validate the temp file is valid bash
    if ! bash -n "${config_file}.tmp" 2>/dev/null; then
        warn "Generated config has invalid syntax - this is a bug"
        secure_delete "${config_file}.tmp"
        return 1
    fi

    # Atomic move
    if ! mv "${config_file}.tmp" "$config_file"; then
        echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" >&2
        echo "â•‘ CRITICAL: Failed to update configuration               â•‘" >&2
        echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" >&2
        echo "â•‘ Could not write to: $config_file                       â•‘" >&2
        echo "â•‘                                                        â•‘" >&2
        echo "â•‘ Possible causes:                                       â•‘" >&2
        echo "â•‘   - Disk full                                          â•‘" >&2
        echo "â•‘   - Permission denied                                  â•‘" >&2
        echo "â•‘   - Filesystem error                                   â•‘" >&2
        echo "â•‘                                                        â•‘" >&2
        echo "â•‘ Check: df -h $(dirname "$config_file")                 â•‘" >&2
        echo "â•‘ Check: ls -la $config_file                             â•‘" >&2
        echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
        secure_delete "${config_file}.tmp"
        return 1
    fi

    return 0
}

# Check if VPN is connected
is_connected() {
    local conn_name="$1"

    # Check if interface exists and is up
    if ! networkctl status "$conn_name" &>/dev/null; then
        return 1
    fi

    # Check if interface has state "routable" or "degraded" (degraded means up but DNS might not work)
    local state
    state=$(networkctl status "$conn_name" 2>/dev/null | grep -E "^\s*State:" | awk '{print $2}')

    if [[ "$state" == "routable" ]] || [[ "$state" == "degraded" ]]; then
        return 0
    fi

    return 1
}

# Interactive config recovery
recover_config() {
    local config_file="$1"

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âš ï¸  Configuration file is missing or corrupted"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Let's recreate it. I'll ask you a few questions..."
    echo ""

    # Question 1: Connection name
    echo "1. What should the systemd-networkd connection be named?"
    echo "   (This is the interface name, default: wg0)"
    read -r -p "   Connection name [wg0]: " conn_name
    conn_name="${conn_name:-wg0}"

    # Validate
    if [[ ! "$conn_name" =~ ^[a-zA-Z0-9._-]+$ ]]; then
        echo "   Invalid name. Using default: wg0"
        conn_name="wg0"
    fi

    # Question 2: Killswitch
    echo ""
    echo "2. Enable killswitch (block internet if VPN drops)?"
    read -r -p "   [y/N]: " killswitch
    [[ "${killswitch,,}" == "y" ]] && killswitch="true" || killswitch="false"

    # Question 3: Allow local network
    echo ""
    echo "3. Allow local network access when killswitch is enabled?"
    read -r -p "   [Y/n]: " allow_local
    [[ "${allow_local,,}" == "n" ]] && allow_local="false" || allow_local="true"

    # Question 4: Autostart
    echo ""
    echo "4. Auto-start LazyVPN on boot?"
    read -r -p "   [y/N]: " autostart
    [[ "${autostart,,}" == "y" ]] && autostart="true" || autostart="false"

    # Question 5: Autoconnect
    echo ""
    echo "5. Auto-connect to VPN on boot?"
    read -r -p "   [y/N]: " autoconnect
    [[ "${autoconnect,,}" == "y" ]] && autoconnect="true" || autoconnect="false"

    # Question 6: Autoconnect mode (if enabled)
    autoconnect_mode="last_used"
    autoconnect_server=""
    if [[ "$autoconnect" == "true" ]]; then
        echo ""
        echo "6. Which server should auto-connect use?"
        echo "   1) Last used server"
        echo "   2) Quickest (lowest latency)"
        echo "   3) Random"
        read -r -p "   Choice [1]: " mode_choice

        case "$mode_choice" in
            2) autoconnect_mode="quickest" ;;
            3) autoconnect_mode="random" ;;
            *) autoconnect_mode="last_used" ;;
        esac
    fi

    # Create config atomically
    echo ""
    echo "Creating configuration..."

    cat > "${config_file}.tmp" << EOF
# LazyVPN Configuration
CONNECTION_NAME=$conn_name
KILLSWITCH=$killswitch
ALLOW_LOCAL_NETWORK=$allow_local
KILLSWITCH_AUTO_DISABLE=true
AUTOSTART=$autostart
AUTOCONNECT=$autoconnect
AUTOCONNECT_MODE=$autoconnect_mode
AUTOCONNECT_SERVER=$autoconnect_server
LAST_CONNECTED_SERVER=
EOF

    # Atomic move
    if ! mv "${config_file}.tmp" "$config_file"; then
        echo "âŒ Error: Failed to create config file"
        echo "   Check permissions on: $(dirname "$config_file")"
        secure_delete "${config_file}.tmp"
        return 1
    fi

    echo "âœ… Configuration created successfully"
    echo ""
    return 0
}

# Load and validate config
load_config() {
    local config_file="${1:-$HOME/.config/lazyvpn/config}"

    # If config doesn't exist or is invalid, run init to fix it
    if ! validate_config "$config_file"; then
        warn "Config missing or incomplete, running lazyvpn-init..."
        local script_dir
        script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        "$script_dir/lazyvpn-init" >/dev/null 2>&1
    fi

    # Source the config
    # shellcheck source=/dev/null
    source "$config_file" || error "Failed to load config"

    # Set defaults for any missing values
    CONNECTION_NAME="${CONNECTION_NAME:-wg0}"
    KILLSWITCH="${KILLSWITCH:-false}"
    ALLOW_LOCAL_NETWORK="${ALLOW_LOCAL_NETWORK:-true}"
    KILLSWITCH_AUTO_DISABLE="${KILLSWITCH_AUTO_DISABLE:-true}"
    DISABLE_IPV6="${DISABLE_IPV6:-true}"
    AUTOSTART="${AUTOSTART:-false}"
    AUTOCONNECT="${AUTOCONNECT:-false}"
    AUTOCONNECT_MODE="${AUTOCONNECT_MODE:-quickest}"
    AUTOCONNECT_SERVER="${AUTOCONNECT_SERVER:-}"
    LAST_CONNECTED_SERVER="${LAST_CONNECTED_SERVER:-}"
    AUTO_RECOVER="${AUTO_RECOVER:-true}"
    AUTO_FAILOVER="${AUTO_FAILOVER:-false}"
    LOG_CONNECTION="${LOG_CONNECTION:-false}"
    LOG_AUTORECOVER="${LOG_AUTORECOVER:-false}"
    LOG_FIREWALL="${LOG_FIREWALL:-false}"
    LOG_PROVIDER="${LOG_PROVIDER:-false}"
    LOG_AUTOSTART="${LOG_AUTOSTART:-false}"
    LOG_MODE="${LOG_MODE:-safe}"
}

# Sanitize log message based on LOG_MODE
sanitize_log() {
    local msg="$1"
    if [[ "${LOG_MODE:-safe}" == "safe" ]]; then
        # Redact WireGuard keys (44-char base64 ending in =)
        msg=$(echo "$msg" | sed -E 's/[A-Za-z0-9+/]{43}=/[redacted-key]/g')
        # Redact IPv4 addresses
        msg=$(echo "$msg" | sed -E 's/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[redacted-ip]/g')
    fi
    echo "$msg"
}

# Write a debug log entry if the given category is enabled
debug_log() {
    local category="$1"
    shift
    local real_home="$HOME"
    if [[ -n "$SUDO_USER" ]]; then
        real_home=$(eval echo ~"$SUDO_USER")
    fi
    local config_dir="$real_home/.config/lazyvpn"
    local log_file="$config_dir/debug.log"

    # Check if this category is enabled
    case "$category" in
        connection)  [[ "${LOG_CONNECTION:-false}" != "true" ]] && return ;;
        autorecover) [[ "${LOG_AUTORECOVER:-false}" != "true" ]] && return ;;
        firewall)    [[ "${LOG_FIREWALL:-false}" != "true" ]] && return ;;
        provider)    [[ "${LOG_PROVIDER:-false}" != "true" ]] && return ;;
        autostart)   [[ "${LOG_AUTOSTART:-false}" != "true" ]] && return ;;
        *) return ;;
    esac

    local msg
    msg=$(sanitize_log "$*")
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$category] $msg" >> "$log_file"

    # Rotate if over 1000 lines
    if [[ -f "$log_file" ]]; then
        local lc
        lc=$(wc -l < "$log_file")
        if [[ $lc -gt 1000 ]]; then
            tail -n 500 "$log_file" > "$log_file.tmp"
            mv "$log_file.tmp" "$log_file"
        fi
    fi
}

# Securely delete files with interactive recovery on failure
# Usage: secure_delete [--sudo] [file1] [file2] ...
#   --sudo  Use sudo shred directly (for root-owned files)
# Returns 0 if all files removed, 1 if any remain
secure_delete() {
    local use_sudo=false
    if [[ "${1:-}" == "--sudo" ]]; then
        use_sudo=true
        shift
    fi

    local files=()
    local shredded=0
    local sudo_shredded=0
    local insecure_deleted=0
    local failed=0
    local failed_files=()
    local failed_errors=()

    # Filter to only existing files (use sudo for existence check if --sudo specified)
    for f in "$@"; do
        if [[ "$use_sudo" == true ]]; then
            sudo test -f "$f" 2>/dev/null && files+=("$f")
        else
            [[ -f "$f" ]] && files+=("$f")
        fi
    done

    # No existing files = silent success
    [[ ${#files[@]} -eq 0 ]] && return 0

    # Phase 1: Attempt shred on each file
    for f in "${files[@]}"; do
        local err
        if [[ "$use_sudo" == true ]]; then
            err=$(sudo shred -u "$f" 2>&1)
        else
            err=$(shred -u "$f" 2>&1)
        fi
        if [[ $? -eq 0 ]]; then
            if [[ "$use_sudo" == true ]]; then
                ((sudo_shredded++))
            else
                ((shredded++))
            fi
        else
            failed_files+=("$f")
            failed_errors+=("$err")
        fi
    done

    # Phase 2: Fast path - all succeeded
    if [[ ${#failed_files[@]} -eq 0 ]]; then
        local total=$((shredded + sudo_shredded))
        echo "âœ“ Securely deleted $total file(s)."
        return 0
    fi

    # Phase 3: Failure report
    echo ""
    echo "â”€â”€ Secure Deletion Report â”€â”€"
    if [[ "$use_sudo" == true ]]; then
        echo "  Sudo Shredded: $sudo_shredded"
    else
        echo "  Shredded: $shredded"
    fi
    echo "  Failed:   ${#failed_files[@]}"
    echo ""
    echo "Errors:"
    for i in "${!failed_files[@]}"; do
        echo "  $(basename "${failed_files[$i]}"): ${failed_errors[$i]}"
    done
    echo ""
    echo "Diagnostic command:"
    if [[ "$use_sudo" == true ]]; then
        echo "  sudo ls -laZ ${failed_files[*]}"
    else
        echo "  ls -laZ ${failed_files[*]}"
    fi
    echo ""
    echo "Report issues: https://github.com/rigs05/lazyVPN-for-Omarchy/issues"
    echo ""

    # Phase 4: Interactive recovery
    if [[ "$use_sudo" == true ]]; then
        echo "How would you like to handle the ${#failed_files[@]} failed file(s)?"
        echo "  1) Retry sudo shred (Secure) [Default]"
        echo "  2) Force delete with sudo rm -f (Insecure)"
        echo "  3) Cancel (Keep files)"
        echo ""
        read -rp "Choice [1]: " choice
        choice="${choice:-1}"

        case "$choice" in
            1)
                for f in "${failed_files[@]}"; do
                    if sudo shred -u "$f" 2>/dev/null; then
                        ((sudo_shredded++))
                    else
                        echo "  Retry failed for: $(basename "$f")"
                        read -rp "  Force delete with sudo rm -f (Insecure)? [Y/n]: " sub_choice
                        sub_choice="${sub_choice:-Y}"
                        if [[ "$sub_choice" =~ ^[Yy]$ ]]; then
                            if sudo rm -f "$f" 2>/dev/null; then
                                ((insecure_deleted++))
                            else
                                ((failed++))
                            fi
                        else
                            ((failed++))
                        fi
                    fi
                done
                ;;
            2)
                for f in "${failed_files[@]}"; do
                    if sudo rm -f "$f" 2>/dev/null; then
                        ((insecure_deleted++))
                    else
                        ((failed++))
                    fi
                done
                ;;
            3)
                failed=${#failed_files[@]}
                echo "  Files preserved."
                ;;
        esac
    else
        echo "How would you like to handle the ${#failed_files[@]} failed file(s)?"
        echo "  1) Try with sudo shred (Secure) [Default]"
        echo "  2) Force delete insecurely (rm -f)"
        echo "  3) Cancel (Keep files)"
        echo ""
        read -rp "Choice [1]: " choice
        choice="${choice:-1}"

        case "$choice" in
            1)
                for f in "${failed_files[@]}"; do
                    if sudo shred -u "$f" 2>/dev/null; then
                        ((sudo_shredded++))
                    else
                        echo "  Sudo shred failed for: $(basename "$f")"
                        read -rp "  Force delete with sudo rm -f (Insecure)? [Y/n]: " sub_choice
                        sub_choice="${sub_choice:-Y}"
                        if [[ "$sub_choice" =~ ^[Yy]$ ]]; then
                            if sudo rm -f "$f" 2>/dev/null; then
                                ((insecure_deleted++))
                            else
                                ((failed++))
                            fi
                        else
                            ((failed++))
                        fi
                    fi
                done
                ;;
            2)
                for f in "${failed_files[@]}"; do
                    if rm -f "$f" 2>/dev/null; then
                        ((insecure_deleted++))
                    else
                        ((failed++))
                    fi
                done
                ;;
            3)
                failed=${#failed_files[@]}
                echo "  Files preserved."
                ;;
        esac
    fi

    # Phase 5: Final tally
    echo ""
    echo "âœ“ Final Status: $shredded Shredded, $sudo_shredded Sudo Shredded, $insecure_deleted Deleted Insecurely, $failed Failed"

    [[ $failed -eq 0 ]] && return 0 || return 1
}

# Convert country code to flag emoji
country_flag() {
    local code="$1"

    # Map common non-ISO codes to proper ISO 3166-1 alpha-2 codes
    case "$code" in
        UK) code="GB" ;;  # United Kingdom -> Great Britain
    esac

    # Convert country code to flag emoji using regional indicator symbols
    # Simple lookup table for A-Z to avoid printf issues
    declare -A flags=(
        [A]="ğŸ‡¦" [B]="ğŸ‡§" [C]="ğŸ‡¨" [D]="ğŸ‡©" [E]="ğŸ‡ª" [F]="ğŸ‡«" [G]="ğŸ‡¬" [H]="ğŸ‡­"
        [I]="ğŸ‡®" [J]="ğŸ‡¯" [K]="ğŸ‡°" [L]="ğŸ‡±" [M]="ğŸ‡²" [N]="ğŸ‡³" [O]="ğŸ‡´" [P]="ğŸ‡µ"
        [Q]="ğŸ‡¶" [R]="ğŸ‡·" [S]="ğŸ‡¸" [T]="ğŸ‡¹" [U]="ğŸ‡º" [V]="ğŸ‡»" [W]="ğŸ‡¼" [X]="ğŸ‡½"
        [Y]="ğŸ‡¾" [Z]="ğŸ‡¿"
    )

    local flag=""
    for (( i=0; i<${#code}; i++ )); do
        local char="${code:$i:1}"
        # Convert to uppercase
        local upper
        upper=$(echo "$char" | tr '[:lower:]' '[:upper:]')
        # Lookup emoji
        flag+="${flags[$upper]}"
    done
    echo "$flag"
}

# Expand country codes to full names
expand_country_name() {
    local code="$1"

    declare -A countries=(
        [US]="United States" [GB]="United Kingdom" [UK]="United Kingdom" [CA]="Canada" [AU]="Australia" [NZ]="New Zealand"
        [DE]="Germany" [FR]="France" [IT]="Italy" [ES]="Spain" [PT]="Portugal" [NL]="Netherlands"
        [BE]="Belgium" [CH]="Switzerland" [AT]="Austria" [SE]="Sweden" [NO]="Norway" [DK]="Denmark"
        [FI]="Finland" [IS]="Iceland" [IE]="Ireland" [PL]="Poland" [CZ]="Czech Republic"
        [HU]="Hungary" [RO]="Romania" [BG]="Bulgaria" [GR]="Greece" [TR]="Turkey" [IL]="Israel"
        [IN]="India" [JP]="Japan" [KR]="South Korea" [CN]="China" [HK]="Hong Kong" [TW]="Taiwan"
        [SG]="Singapore" [MY]="Malaysia" [TH]="Thailand" [VN]="Vietnam" [ID]="Indonesia" [PH]="Philippines"
        [BR]="Brazil" [AR]="Argentina" [CL]="Chile" [MX]="Mexico" [CO]="Colombia" [PE]="Peru"
        [ZA]="South Africa" [EG]="Egypt" [KE]="Kenya" [NG]="Nigeria" [MA]="Morocco"
        [RU]="Russia" [UA]="Ukraine" [BY]="Belarus" [KZ]="Kazakhstan"
        [AE]="UAE" [SA]="Saudi Arabia" [QA]="Qatar" [OM]="Oman" [KW]="Kuwait"
        [CR]="Costa Rica" [PA]="Panama" [UY]="Uruguay" [VE]="Venezuela"
        [LU]="Luxembourg" [LV]="Latvia" [LT]="Lithuania" [EE]="Estonia" [SK]="Slovakia"
        [SI]="Slovenia" [HR]="Croatia" [RS]="Serbia" [BA]="Bosnia" [MK]="North Macedonia"
        [AL]="Albania" [MT]="Malta" [CY]="Cyprus" [GE]="Georgia" [AM]="Armenia" [AZ]="Azerbaijan"
    )

    if [[ -n "${countries[$code]}" ]]; then
        echo "${countries[$code]}"
    else
        # Return original if no mapping found
        echo "$code"
    fi
}

# Expand location codes to full names
expand_location_name() {
    local code="$1"

    # US State codes
    declare -A us_states=(
        [AL]="Alabama" [AK]="Alaska" [AZ]="Arizona" [AR]="Arkansas" [CA]="California"
        [CO]="Colorado" [CT]="Connecticut" [DE]="Delaware" [FL]="Florida" [GA]="Georgia"
        [HI]="Hawaii" [ID]="Idaho" [IL]="Illinois" [IN]="Indiana" [IA]="Iowa"
        [KS]="Kansas" [KY]="Kentucky" [LA]="Louisiana" [ME]="Maine" [MD]="Maryland"
        [MA]="Massachusetts" [MI]="Michigan" [MN]="Minnesota" [MS]="Mississippi" [MO]="Missouri"
        [MT]="Montana" [NE]="Nebraska" [NV]="Nevada" [NH]="New Hampshire" [NJ]="New Jersey"
        [NM]="New Mexico" [NY]="New York" [NC]="North Carolina" [ND]="North Dakota" [OH]="Ohio"
        [OK]="Oklahoma" [OR]="Oregon" [PA]="Pennsylvania" [RI]="Rhode Island" [SC]="South Carolina"
        [SD]="South Dakota" [TN]="Tennessee" [TX]="Texas" [UT]="Utah" [VT]="Vermont"
        [VA]="Virginia" [WA]="Washington" [WV]="West Virginia" [WI]="Wisconsin" [WY]="Wyoming"
        [DC]="Washington DC"
    )

    # Canadian province codes
    declare -A canadian_provinces=(
        [AB]="Alberta" [BC]="British Columbia" [MB]="Manitoba" [NB]="New Brunswick"
        [NL]="Newfoundland" [NS]="Nova Scotia" [ON]="Ontario" [PE]="Prince Edward Island"
        [QC]="Quebec" [SK]="Saskatchewan" [NT]="Northwest Territories" [NU]="Nunavut"
        [YT]="Yukon"
    )

    # Swedish county/region codes (for ProtonVPN SE servers)
    declare -A swedish_regions=(
        [RO]="Roslagen" [SK]="SkÃ¥ne" [ST]="Stockholm" [VS]="VÃ¤stmanland"
        [VG]="VÃ¤stra GÃ¶taland" [NO]="Norrland" [GO]="GÃ¶teborg" [MA]="MalmÃ¶"
    )

    # Common city codes (ProtonVPN and others)
    declare -A city_codes=(
        [NYC]="New York City" [LA]="Los Angeles" [SF]="San Francisco" [CHI]="Chicago"
        [MIA]="Miami" [SEA]="Seattle" [DEN]="Denver" [ATL]="Atlanta" [PHX]="Phoenix"
        [DAL]="Dallas" [PHI]="Philadelphia" [HOU]="Houston" [BOS]="Boston" [DET]="Detroit"
        [LV]="Las Vegas" [PDX]="Portland" [SLC]="Salt Lake City" [SAN]="San Diego"
        [LON]="London" [PAR]="Paris" [BER]="Berlin" [AMS]="Amsterdam" [ZUR]="Zurich"
        [FRA]="Frankfurt" [MIL]="Milan" [ROM]="Rome" [MAD]="Madrid" [BAR]="Barcelona"
        [VIE]="Vienna" [BRU]="Brussels" [OSL]="Oslo" [STO]="Stockholm" [HEL]="Helsinki"
        [WAR]="Warsaw" [PRA]="Prague" [BUD]="Budapest" [DUB]="Dublin" [CPH]="Copenhagen"
        [LIS]="Lisbon" [ATH]="Athens" [BUC]="Bucharest" [SOF]="Sofia" [IST]="Istanbul"
        [TYO]="Tokyo" [SEO]="Seoul" [SIN]="Singapore" [HKG]="Hong Kong" [SYD]="Sydney"
        [MEL]="Melbourne" [TOR]="Toronto" [MON]="Montreal" [VAN]="Vancouver"
        [Tor]="Tor" [Malmoe]="MalmÃ¶" [Goeteborg]="GÃ¶teborg"
    )

    # Check if it's a US state code
    if [[ -n "${us_states[$code]}" ]]; then
        echo "${us_states[$code]}"
        return
    fi

    # Check if it's a Canadian province code
    if [[ -n "${canadian_provinces[$code]}" ]]; then
        echo "${canadian_provinces[$code]}"
        return
    fi

    # Check if it's a Swedish region code
    if [[ -n "${swedish_regions[$code]}" ]]; then
        echo "${swedish_regions[$code]}"
        return
    fi

    # Check if it's a known city code
    if [[ -n "${city_codes[$code]}" ]]; then
        echo "${city_codes[$code]}"
        return
    fi

    # Return original if no mapping found
    echo "$code"
}

# Get pretty formatted server name: "ğŸ‡ºğŸ‡¸ US - New York #123" or "ğŸ‡ºğŸ‡¸ US - California, Los Angeles (123)"
get_pretty_server_name() {
    local server_name="$1"
    local script_dir="${2:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"

    # Get server info
    local info_output
    info_output=$("$script_dir/lazyvpn-get-server-info" "$server_name" 2>/dev/null)

    if [[ -z "$info_output" ]]; then
        # Fallback to plain name if info fetch fails
        echo "$server_name"
        return
    fi

    local country state city number provider services
    country=$(echo "$info_output" | grep "^country=" | cut -d= -f2)
    state=$(echo "$info_output" | grep "^state=" | cut -d= -f2)
    city=$(echo "$info_output" | grep "^city=" | cut -d= -f2)
    number=$(echo "$info_output" | grep "^number=" | cut -d= -f2)
    provider=$(echo "$info_output" | grep "^provider=" | cut -d= -f2)
    services=$(echo "$info_output" | grep "^services=" | cut -d= -f2)

    # Build pretty name
    local pretty_name=""
    local flag=""

    # Check if this is a Secure Core server (multi-hop)
    local is_secure_core=false
    local entry_country=""
    local exit_country=""
    if [[ ",$services," == *",securecore,"* ]]; then
        is_secure_core=true
        # For Secure Core servers:
        # - country field = ENTRY country (CH, IS, SE)
        # - Exit country is in city OR state field (whichever is the second component)
        entry_country="$country"

        # Exit country can be in city (if 3+ components) or state (if 2 components)
        if [[ -n "$city" ]]; then
            exit_country="$city"
        elif [[ -n "$state" ]]; then
            exit_country="$state"
        fi

        # Build dual flag for Secure Core
        if [[ -n "$entry_country" ]] && [[ -n "$exit_country" ]]; then
            flag="$(country_flag "$entry_country")â†’$(country_flag "$exit_country")"
        else
            # Fallback to single flag if parsing failed
            flag=$(country_flag "$country")
        fi
    else
        # Regular server - single flag
        if [[ -n "$country" ]] && [[ "$country" != "Unknown" ]]; then
            flag=$(country_flag "$country")
        else
            pretty_name="$server_name"
            return
        fi
    fi

    # Add state and/or city with smart formatting
    if [[ -n "$state" ]] && [[ -n "$city" ]]; then
        # Both state and city
        local expanded_country expanded_state expanded_city
        expanded_country=$(expand_country_name "$country")
        expanded_state=$(expand_location_name "$state")
        expanded_city=$(expand_location_name "$city")

        # Special case for Secure Core: show entryâ†’exit country names
        if [[ "$is_secure_core" == true ]]; then
            local exit_country_name
            exit_country_name=$(expand_country_name "$exit_country")
            pretty_name="$flag $expanded_country â†’ $exit_country_name"
        # Special case for DC (Washington DC is a city-state)
        elif [[ "$state" == "DC" ]] && { [[ "$city" == "Washington" ]] || [[ "$city" == "DC" ]]; }; then
            pretty_name="$flag $expanded_country - Washington DC"
        else
            # Regular state+city: "ğŸ‡ºğŸ‡¸ United States - California, Los Angeles"
            pretty_name="$flag $expanded_country - $expanded_state, $expanded_city"
        fi
    elif [[ -n "$state" ]]; then
        # Just state, no city
        local expanded_country expanded_state
        expanded_country=$(expand_country_name "$country")
        expanded_state=$(expand_location_name "$state")

        # Special case for Secure Core: state field contains exit country
        if [[ "$is_secure_core" == true ]]; then
            local exit_country_name
            exit_country_name=$(expand_country_name "$exit_country")
            pretty_name="$flag $expanded_country â†’ $exit_country_name"
        else
            # Regular: "ğŸ‡ºğŸ‡¸ United States - New York" or "ğŸ‡¸ğŸ‡ª Sweden - Stockholm"
            pretty_name="$flag $expanded_country - $expanded_state"
        fi
    elif [[ -n "$city" ]]; then
        # Just city/location: "ğŸ‡ºğŸ‡¸ United States - New York"
        local expanded_country expanded_city
        expanded_country=$(expand_country_name "$country")
        expanded_city=$(expand_location_name "$city")

        # Check if city looks like a US state code (2 uppercase letters)
        if [[ "$city" =~ ^[A-Z]{2}$ ]] && [[ "$country" == "US" ]]; then
            # It's a US state - format as "United States - State Name"
            pretty_name="$flag $expanded_country - $expanded_city"
        else
            # Regular city/location
            pretty_name="$flag $expanded_country - $expanded_city"
        fi
    else
        # No city or state: "ğŸ‡¸ğŸ‡ª Sweden"
        local expanded_country
        expanded_country=$(expand_country_name "$country")
        pretty_name="$flag $expanded_country"
    fi

    # Add server number with parentheses if available
    if [[ -n "$number" ]]; then
        pretty_name="$pretty_name ($number)"
    fi

    # Add feature emojis based on services
    # Use comma-separated matching to avoid substring false positives
    local feature_emojis=""
    if [[ -n "$services" ]]; then
        # P2P support
        if [[ ",$services," == *",p2p,"* ]]; then
            feature_emojis="${feature_emojis}ğŸ”„"
        fi
        # Tor support
        if [[ ",$services," == *",tor,"* ]]; then
            feature_emojis="${feature_emojis}ğŸ§…"
        fi
        # Secure Core
        if [[ ",$services," == *",securecore,"* ]]; then
            feature_emojis="${feature_emojis}ğŸ”’"
        fi
        # Streaming
        if [[ ",$services," == *",streaming,"* ]]; then
            feature_emojis="${feature_emojis}ğŸ“º"
        fi
        # Free tier
        if [[ ",$services," == *",free,"* ]]; then
            feature_emojis="${feature_emojis}ğŸ¤¡"
        fi
        # VPN Accelerator
        if [[ ",$services," == *",accelerator,"* ]]; then
            feature_emojis="${feature_emojis}ğŸš€"
        fi
        # NetShield Level 1 (malware blocking only)
        if [[ ",$services," == *",netshield1,"* ]]; then
            feature_emojis="${feature_emojis}ğŸ—¡ï¸"
        fi
        # NetShield Level 2 (malware + ad blocking)
        if [[ ",$services," == *",netshield2,"* ]]; then
            feature_emojis="${feature_emojis}âš”ï¸"
        fi
        # Moderate NAT (gaming optimized)
        if [[ ",$services," == *",moderatenat,"* ]]; then
            feature_emojis="${feature_emojis}ğŸ®"
        fi
    fi

    # Add feature emojis if any were found
    if [[ -n "$feature_emojis" ]]; then
        pretty_name="$pretty_name $feature_emojis"
    fi

    # Add provider if known
    if [[ -n "$provider" ]]; then
        pretty_name="$pretty_name â€¢ $provider"
    fi

    echo "$pretty_name"
}

# Generate standardized server filename from a config file
# Input: config file path, destination directory
# Output: standardized filename (without .conf extension)
# Example: "Proton-US-NY#123" or "Mullvad-SE-Stockholm#5"
generate_standard_server_name() {
    local config_file="$1"
    local dest_dir="$2"
    local original_name=$(basename "$config_file" .conf)

    # Parse config for endpoint
    local endpoint=$(grep -m1 "^Endpoint" "$config_file" | cut -d= -f2 | tr -d ' ')
    local server_ip=$(echo "$endpoint" | cut -d: -f1)

    # Detect provider using shared function
    local provider=""
    local provider_id
    provider_id=$(detect_provider "$config_file")
    if [[ -n "$provider_id" ]]; then
        provider="${PROVIDER_PREFIX[$provider_id]}"
    fi

    # Try to parse location from original filename
    local parse_name="$original_name"
    # Strip provider prefix
    parse_name=$(echo "$parse_name" | sed -E 's/^(proton|mullvad|ivpn|pia|nord|surf|wg|vpn|server)-//i')

    local country="" state="" city="" number=""

    # Try to extract location from filename
    if [[ "$parse_name" =~ ^([A-Z]{2})[-_]([A-Z]{2})[-_]([A-Za-z]+)[-_#]([0-9]+) ]]; then
        # US-CA-LosAngeles#123
        country="${BASH_REMATCH[1]}"
        state="${BASH_REMATCH[2]}"
        city="${BASH_REMATCH[3]}"
        number="${BASH_REMATCH[4]}"
    elif [[ "$parse_name" =~ ^([A-Z]{2,})[-_]([A-Za-z]+)[-_#]([0-9]+) ]]; then
        # SE-Stockholm-130 or US-DC-30
        country="${BASH_REMATCH[1]}"
        city="${BASH_REMATCH[2]}"
        number="${BASH_REMATCH[3]}"
    elif [[ "$parse_name" =~ ^([A-Z]{2,})[-_]([0-9]+) ]]; then
        # SE-130 or US-30
        country="${BASH_REMATCH[1]}"
        number="${BASH_REMATCH[2]}"
    elif [[ "$parse_name" =~ ^([A-Z]{2,})#([0-9]+) ]]; then
        # SE#130
        country="${BASH_REMATCH[1]}"
        number="${BASH_REMATCH[2]}"
    fi

    # Filter out tier keywords from location fields (they're features, not locations)
    if [[ "$city" =~ ^(FREE|PLUS|PREMIUM|PRO)$ ]]; then
        city=""
    fi
    if [[ "$state" =~ ^(FREE|PLUS|PREMIUM|PRO)$ ]]; then
        state=""
    fi

    # Use IP geolocation to fill in missing location info (city/state)
    # Always lookup if we have an IP and are missing state or city
    if [[ -n "$server_ip" ]] && { [[ -z "$state" ]] || [[ -z "$city" ]]; }; then
        # Use temporary geolocation lookup (no cache for this one-time operation)
        local response
        response=$(curl -s --connect-timeout 5 --max-time 10 \
            "http://ip-api.com/json/${server_ip}?fields=status,countryCode,region,city" 2>/dev/null)

        if [[ $? -eq 0 ]] && [[ -n "$response" ]]; then
            local status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
            if [[ "$status" == "success" ]]; then
                local geo_country=$(echo "$response" | grep -o '"countryCode":"[^"]*"' | cut -d'"' -f4)
                local geo_city=$(echo "$response" | grep -o '"city":"[^"]*"' | cut -d'"' -f4)
                local geo_region=$(echo "$response" | grep -o '"region":"[^"]*"' | cut -d'"' -f4)

                # Use geolocation country if we don't have one from filename
                if [[ -z "$country" ]] && [[ -n "$geo_country" ]]; then
                    country="$geo_country"
                fi

                # Fill in state if missing (for US/CA, use region code)
                if [[ -z "$state" ]] && [[ -n "$geo_region" ]]; then
                    if [[ "$country" == "US" ]] || [[ "$country" == "CA" ]] || [[ "$country" == "SE" ]]; then
                        state="$geo_region"
                    fi
                fi

                # Fill in city if missing (clean it for filename)
                if [[ -z "$city" ]] && [[ -n "$geo_city" ]]; then
                    city=$(echo "$geo_city" | tr -d ' ')
                fi
            fi
        fi
    fi

    # Detect features from filename and config
    local features=""
    if [[ "$original_name" =~ [Pp]2[Pp] ]] || grep -qiw "p2p" "$config_file" 2>/dev/null; then
        features="${features:+$features-}P2P"
    fi
    if [[ "$original_name" =~ -[Tt]or- ]] || [[ "$original_name" =~ -[Tt]or$ ]] || [[ "$original_name" =~ ^[Tt]or- ]] || grep -qiE '\btor\b' "$config_file" 2>/dev/null; then
        features="${features:+$features-}Tor"
    fi
    if [[ "$original_name" =~ [Ss]ecure[_-]?[Cc]ore ]] || grep -qiE 'secure.core|securecore' "$config_file" 2>/dev/null; then
        features="${features:+$features-}SC"
    fi
    if [[ "$original_name" =~ [Ss]treaming ]] || grep -qiw "streaming" "$config_file" 2>/dev/null; then
        features="${features:+$features-}Stream"
    fi

    # Generate number if missing (find next available)
    if [[ -z "$number" ]] && [[ -n "$dest_dir" ]]; then
        # Find existing servers with same location
        local max_num=0
        local search_pattern="${provider:+$provider-}${country}${state:+-$state}${city:+-$city}${features:+-$features}#"

        shopt -s nullglob
        for existing in "$dest_dir"/*.conf; do
            local existing_base=$(basename "$existing" .conf)
            if [[ "$existing_base" =~ ^${search_pattern}([0-9]+)$ ]]; then
                local num="${BASH_REMATCH[1]}"
                if [[ $num -gt $max_num ]]; then
                    max_num=$num
                fi
            fi
        done
        shopt -u nullglob
        number=$((max_num + 1))
    fi

    # Build standardized name
    local std_name=""

    # Add provider prefix
    if [[ -n "$provider" ]]; then
        std_name="$provider"
    fi

    # Add country
    if [[ -n "$country" ]]; then
        std_name="${std_name:+$std_name-}${country}"
    else
        # Fallback: keep original name if we couldn't determine location
        echo "$original_name"
        return
    fi

    # Add state (US only)
    if [[ -n "$state" ]]; then
        std_name="${std_name}-${state}"
    fi

    # Add city
    if [[ -n "$city" ]]; then
        std_name="${std_name}-${city}"
    fi

    # Add features
    if [[ -n "$features" ]]; then
        std_name="${std_name}-${features}"
    fi

    # Add number
    if [[ -n "$number" ]]; then
        std_name="${std_name}#${number}"
    fi

    echo "$std_name"
}
