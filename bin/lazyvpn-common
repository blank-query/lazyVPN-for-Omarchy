#!/bin/bash

# LazyVPN Common Functions Library (systemd-networkd version)
# Source this file in all lazyvpn scripts

# Error handling functions
error() {
    echo "Error: $*" >&2
    exit 1
}

warn() {
    echo "Warning: $*" >&2
}

info() {
    echo "$*"
}

# Send notification (dismisses old LazyVPN notifications first to avoid spam)
notify() {
    omarchy-notification-dismiss "LazyVPN" 2>/dev/null || true
    notify-send "LazyVPN" "$1"
}

# Validate config file exists and is readable
validate_config() {
    local config_file="$1"

    # Check if config exists
    if [[ ! -f "$config_file" ]]; then
        return 1
    fi

    # Check if config is readable and has required fields
    if ! grep -q "^CONNECTION_NAME=" "$config_file" 2>/dev/null; then
        return 1
    fi

    # Check if file is valid bash syntax
    if ! bash -n "$config_file" 2>/dev/null; then
        return 1
    fi

    return 0
}

# Atomic config update
atomic_config_update() {
    local key="$1"
    local value="$2"
    local config_file="$3"

    # Validate inputs
    if [[ -z "$key" ]] || [[ -z "$config_file" ]]; then
        warn "atomic_config_update requires key and config_file"
        return 1
    fi

    # Create updated config in temp file
    if [[ -f "$config_file" ]]; then
        # Check if key exists, update or append
        if grep -q "^${key}=" "$config_file" 2>/dev/null; then
            # Update existing line
            if ! sed "s|^${key}=.*|${key}=${value}|" "$config_file" > "${config_file}.tmp"; then
                warn "Failed to update config (sed failed)"
                rm -f "${config_file}.tmp"
                return 1
            fi
        else
            # Key doesn't exist, append it
            cp "$config_file" "${config_file}.tmp" || return 1
            echo "${key}=${value}" >> "${config_file}.tmp"
        fi
    else
        # Create new config with just this key
        echo "${key}=${value}" > "${config_file}.tmp"
    fi

    # Validate the temp file is valid bash
    if ! bash -n "${config_file}.tmp" 2>/dev/null; then
        warn "Generated config has invalid syntax - this is a bug"
        rm -f "${config_file}.tmp"
        return 1
    fi

    # Atomic move
    if ! mv "${config_file}.tmp" "$config_file"; then
        echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" >&2
        echo "â•‘ CRITICAL: Failed to update configuration               â•‘" >&2
        echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" >&2
        echo "â•‘ Could not write to: $config_file                       â•‘" >&2
        echo "â•‘                                                        â•‘" >&2
        echo "â•‘ Possible causes:                                       â•‘" >&2
        echo "â•‘   - Disk full                                          â•‘" >&2
        echo "â•‘   - Permission denied                                  â•‘" >&2
        echo "â•‘   - Filesystem error                                   â•‘" >&2
        echo "â•‘                                                        â•‘" >&2
        echo "â•‘ Check: df -h $(dirname "$config_file")                 â•‘" >&2
        echo "â•‘ Check: ls -la $config_file                             â•‘" >&2
        echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
        rm -f "${config_file}.tmp"
        return 1
    fi

    return 0
}

# Check if VPN is connected
is_connected() {
    local conn_name="$1"

    # Check if interface exists and is up
    if ! networkctl status "$conn_name" &>/dev/null; then
        return 1
    fi

    # Check if interface has state "routable" or "degraded" (degraded means up but DNS might not work)
    local state
    state=$(networkctl status "$conn_name" 2>/dev/null | grep -E "^\s*State:" | awk '{print $2}')

    if [[ "$state" == "routable" ]] || [[ "$state" == "degraded" ]]; then
        return 0
    fi

    return 1
}

# Interactive config recovery
recover_config() {
    local config_file="$1"

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âš ï¸  Configuration file is missing or corrupted"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Let's recreate it. I'll ask you a few questions..."
    echo ""

    # Question 1: Connection name
    echo "1. What should the systemd-networkd connection be named?"
    echo "   (This is the interface name, default: wg0)"
    read -r -p "   Connection name [wg0]: " conn_name
    conn_name="${conn_name:-wg0}"

    # Validate
    if [[ ! "$conn_name" =~ ^[a-zA-Z0-9._-]+$ ]]; then
        echo "   Invalid name. Using default: wg0"
        conn_name="wg0"
    fi

    # Question 2: Killswitch
    echo ""
    echo "2. Enable killswitch (block internet if VPN drops)?"
    read -r -p "   [y/N]: " killswitch
    [[ "${killswitch,,}" == "y" ]] && killswitch="true" || killswitch="false"

    # Question 3: Allow local network
    echo ""
    echo "3. Allow local network access when killswitch is enabled?"
    read -r -p "   [Y/n]: " allow_local
    [[ "${allow_local,,}" == "n" ]] && allow_local="false" || allow_local="true"

    # Question 4: Autostart
    echo ""
    echo "4. Auto-start LazyVPN on boot?"
    read -r -p "   [y/N]: " autostart
    [[ "${autostart,,}" == "y" ]] && autostart="true" || autostart="false"

    # Question 5: Autoconnect
    echo ""
    echo "5. Auto-connect to VPN on boot?"
    read -r -p "   [y/N]: " autoconnect
    [[ "${autoconnect,,}" == "y" ]] && autoconnect="true" || autoconnect="false"

    # Question 6: Autoconnect mode (if enabled)
    autoconnect_mode="last_used"
    autoconnect_server=""
    if [[ "$autoconnect" == "true" ]]; then
        echo ""
        echo "6. Which server should auto-connect use?"
        echo "   1) Last used server"
        echo "   2) Quickest (lowest latency)"
        echo "   3) Random"
        read -r -p "   Choice [1]: " mode_choice

        case "$mode_choice" in
            2) autoconnect_mode="quickest" ;;
            3) autoconnect_mode="random" ;;
            *) autoconnect_mode="last_used" ;;
        esac
    fi

    # Create config atomically
    echo ""
    echo "Creating configuration..."

    cat > "${config_file}.tmp" << EOF
# LazyVPN Configuration
CONNECTION_NAME=$conn_name
KILLSWITCH=$killswitch
ALLOW_LOCAL_NETWORK=$allow_local
KILLSWITCH_AUTO_DISABLE=true
AUTOSTART=$autostart
AUTOCONNECT=$autoconnect
AUTOCONNECT_MODE=$autoconnect_mode
AUTOCONNECT_SERVER=$autoconnect_server
LAST_CONNECTED_SERVER=
EOF

    # Atomic move
    if ! mv "${config_file}.tmp" "$config_file"; then
        echo "âŒ Error: Failed to create config file"
        echo "   Check permissions on: $(dirname "$config_file")"
        rm -f "${config_file}.tmp"
        return 1
    fi

    echo "âœ… Configuration created successfully"
    echo ""
    return 0
}

# Load and validate config
load_config() {
    local config_file="${1:-$HOME/.config/lazyvpn/config}"

    # If config doesn't exist or is invalid, run init to fix it
    if ! validate_config "$config_file"; then
        warn "Config missing or incomplete, running lazyvpn-init..."
        local script_dir
        script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        "$script_dir/lazyvpn-init" >/dev/null 2>&1
    fi

    # Source the config
    # shellcheck source=/dev/null
    source "$config_file" || error "Failed to load config"

    # Set defaults for any missing values
    CONNECTION_NAME="${CONNECTION_NAME:-wg0}"
    KILLSWITCH="${KILLSWITCH:-false}"
    ALLOW_LOCAL_NETWORK="${ALLOW_LOCAL_NETWORK:-true}"
    KILLSWITCH_AUTO_DISABLE="${KILLSWITCH_AUTO_DISABLE:-true}"
    DISABLE_IPV6="${DISABLE_IPV6:-true}"
    AUTOSTART="${AUTOSTART:-false}"
    AUTOCONNECT="${AUTOCONNECT:-false}"
    AUTOCONNECT_MODE="${AUTOCONNECT_MODE:-quickest}"
    AUTOCONNECT_SERVER="${AUTOCONNECT_SERVER:-}"
    LAST_CONNECTED_SERVER="${LAST_CONNECTED_SERVER:-}"
    AUTO_RECOVER="${AUTO_RECOVER:-true}"
    AUTO_FAILOVER="${AUTO_FAILOVER:-false}"
}

# Convert country code to flag emoji
country_flag() {
    local code="$1"
    # Convert country code to flag emoji using regional indicator symbols
    # Simple lookup table for A-Z to avoid printf issues
    declare -A flags=(
        [A]="ðŸ‡¦" [B]="ðŸ‡§" [C]="ðŸ‡¨" [D]="ðŸ‡©" [E]="ðŸ‡ª" [F]="ðŸ‡«" [G]="ðŸ‡¬" [H]="ðŸ‡­"
        [I]="ðŸ‡®" [J]="ðŸ‡¯" [K]="ðŸ‡°" [L]="ðŸ‡±" [M]="ðŸ‡²" [N]="ðŸ‡³" [O]="ðŸ‡´" [P]="ðŸ‡µ"
        [Q]="ðŸ‡¶" [R]="ðŸ‡·" [S]="ðŸ‡¸" [T]="ðŸ‡¹" [U]="ðŸ‡º" [V]="ðŸ‡»" [W]="ðŸ‡¼" [X]="ðŸ‡½"
        [Y]="ðŸ‡¾" [Z]="ðŸ‡¿"
    )

    local flag=""
    for (( i=0; i<${#code}; i++ )); do
        local char="${code:$i:1}"
        # Convert to uppercase
        local upper
        upper=$(echo "$char" | tr '[:lower:]' '[:upper:]')
        # Lookup emoji
        flag+="${flags[$upper]}"
    done
    echo "$flag"
}

# Record performance data
record_performance() {
    local server="$1"
    local type="$2"        # "speed" or "latency"
    local value="$3"       # numeric value
    local status="$4"      # "ok" or "failed"
    local config_dir="${5:-$HOME/.config/lazyvpn}"

    local perf_dir="$config_dir/performance"
    mkdir -p "$perf_dir"

    local perf_file="$perf_dir/${server}.log"
    local timestamp=$(date +%s)

    # Append performance data: timestamp|type|value|status
    echo "$timestamp|$type|$value|$status" >> "$perf_file"

    # Keep log size reasonable (max 100 entries per server)
    if [[ -f "$perf_file" ]]; then
        line_count=$(wc -l < "$perf_file")
        if [[ $line_count -gt 100 ]]; then
            tail -n 100 "$perf_file" > "$perf_file.tmp"
            mv "$perf_file.tmp" "$perf_file"
        fi
    fi
}

# Expand country codes to full names
expand_country_name() {
    local code="$1"

    declare -A countries=(
        [US]="United States" [GB]="United Kingdom" [CA]="Canada" [AU]="Australia" [NZ]="New Zealand"
        [DE]="Germany" [FR]="France" [IT]="Italy" [ES]="Spain" [PT]="Portugal" [NL]="Netherlands"
        [BE]="Belgium" [CH]="Switzerland" [AT]="Austria" [SE]="Sweden" [NO]="Norway" [DK]="Denmark"
        [FI]="Finland" [IS]="Iceland" [IE]="Ireland" [PL]="Poland" [CZ]="Czech Republic"
        [HU]="Hungary" [RO]="Romania" [BG]="Bulgaria" [GR]="Greece" [TR]="Turkey" [IL]="Israel"
        [IN]="India" [JP]="Japan" [KR]="South Korea" [CN]="China" [HK]="Hong Kong" [TW]="Taiwan"
        [SG]="Singapore" [MY]="Malaysia" [TH]="Thailand" [VN]="Vietnam" [ID]="Indonesia" [PH]="Philippines"
        [BR]="Brazil" [AR]="Argentina" [CL]="Chile" [MX]="Mexico" [CO]="Colombia" [PE]="Peru"
        [ZA]="South Africa" [EG]="Egypt" [KE]="Kenya" [NG]="Nigeria" [MA]="Morocco"
        [RU]="Russia" [UA]="Ukraine" [BY]="Belarus" [KZ]="Kazakhstan"
        [AE]="UAE" [SA]="Saudi Arabia" [QA]="Qatar" [OM]="Oman" [KW]="Kuwait"
        [CR]="Costa Rica" [PA]="Panama" [UY]="Uruguay" [VE]="Venezuela"
        [LU]="Luxembourg" [LV]="Latvia" [LT]="Lithuania" [EE]="Estonia" [SK]="Slovakia"
        [SI]="Slovenia" [HR]="Croatia" [RS]="Serbia" [BA]="Bosnia" [MK]="North Macedonia"
        [AL]="Albania" [MT]="Malta" [CY]="Cyprus" [GE]="Georgia" [AM]="Armenia" [AZ]="Azerbaijan"
    )

    if [[ -n "${countries[$code]}" ]]; then
        echo "${countries[$code]}"
    else
        # Return original if no mapping found
        echo "$code"
    fi
}

# Expand location codes to full names
expand_location_name() {
    local code="$1"

    # US State codes
    declare -A us_states=(
        [AL]="Alabama" [AK]="Alaska" [AZ]="Arizona" [AR]="Arkansas" [CA]="California"
        [CO]="Colorado" [CT]="Connecticut" [DE]="Delaware" [FL]="Florida" [GA]="Georgia"
        [HI]="Hawaii" [ID]="Idaho" [IL]="Illinois" [IN]="Indiana" [IA]="Iowa"
        [KS]="Kansas" [KY]="Kentucky" [LA]="Louisiana" [ME]="Maine" [MD]="Maryland"
        [MA]="Massachusetts" [MI]="Michigan" [MN]="Minnesota" [MS]="Mississippi" [MO]="Missouri"
        [MT]="Montana" [NE]="Nebraska" [NV]="Nevada" [NH]="New Hampshire" [NJ]="New Jersey"
        [NM]="New Mexico" [NY]="New York" [NC]="North Carolina" [ND]="North Dakota" [OH]="Ohio"
        [OK]="Oklahoma" [OR]="Oregon" [PA]="Pennsylvania" [RI]="Rhode Island" [SC]="South Carolina"
        [SD]="South Dakota" [TN]="Tennessee" [TX]="Texas" [UT]="Utah" [VT]="Vermont"
        [VA]="Virginia" [WA]="Washington" [WV]="West Virginia" [WI]="Wisconsin" [WY]="Wyoming"
        [DC]="Washington DC"
    )

    # Canadian province codes
    declare -A canadian_provinces=(
        [AB]="Alberta" [BC]="British Columbia" [MB]="Manitoba" [NB]="New Brunswick"
        [NL]="Newfoundland" [NS]="Nova Scotia" [ON]="Ontario" [PE]="Prince Edward Island"
        [QC]="Quebec" [SK]="Saskatchewan" [NT]="Northwest Territories" [NU]="Nunavut"
        [YT]="Yukon"
    )

    # Swedish county/region codes (for ProtonVPN SE servers)
    declare -A swedish_regions=(
        [RO]="Roslagen" [SK]="SkÃ¥ne" [ST]="Stockholm" [VS]="VÃ¤stmanland"
        [VG]="VÃ¤stra GÃ¶taland" [NO]="Norrland" [GO]="GÃ¶teborg" [MA]="MalmÃ¶"
    )

    # Common city codes (ProtonVPN and others)
    declare -A city_codes=(
        [NYC]="New York City" [LA]="Los Angeles" [SF]="San Francisco" [CHI]="Chicago"
        [MIA]="Miami" [SEA]="Seattle" [DEN]="Denver" [ATL]="Atlanta" [PHX]="Phoenix"
        [DAL]="Dallas" [PHI]="Philadelphia" [HOU]="Houston" [BOS]="Boston" [DET]="Detroit"
        [LV]="Las Vegas" [PDX]="Portland" [SLC]="Salt Lake City" [SAN]="San Diego"
        [LON]="London" [PAR]="Paris" [BER]="Berlin" [AMS]="Amsterdam" [ZUR]="Zurich"
        [FRA]="Frankfurt" [MIL]="Milan" [ROM]="Rome" [MAD]="Madrid" [BAR]="Barcelona"
        [VIE]="Vienna" [BRU]="Brussels" [OSL]="Oslo" [STO]="Stockholm" [HEL]="Helsinki"
        [WAR]="Warsaw" [PRA]="Prague" [BUD]="Budapest" [DUB]="Dublin" [CPH]="Copenhagen"
        [LIS]="Lisbon" [ATH]="Athens" [BUC]="Bucharest" [SOF]="Sofia" [IST]="Istanbul"
        [TYO]="Tokyo" [SEO]="Seoul" [SIN]="Singapore" [HKG]="Hong Kong" [SYD]="Sydney"
        [MEL]="Melbourne" [TOR]="Toronto" [MON]="Montreal" [VAN]="Vancouver"
        [Tor]="Tor" [Malmoe]="MalmÃ¶" [Goeteborg]="GÃ¶teborg"
    )

    # Check if it's a US state code
    if [[ -n "${us_states[$code]}" ]]; then
        echo "${us_states[$code]}"
        return
    fi

    # Check if it's a Canadian province code
    if [[ -n "${canadian_provinces[$code]}" ]]; then
        echo "${canadian_provinces[$code]}"
        return
    fi

    # Check if it's a Swedish region code
    if [[ -n "${swedish_regions[$code]}" ]]; then
        echo "${swedish_regions[$code]}"
        return
    fi

    # Check if it's a known city code
    if [[ -n "${city_codes[$code]}" ]]; then
        echo "${city_codes[$code]}"
        return
    fi

    # Return original if no mapping found
    echo "$code"
}

# Get pretty formatted server name: "ðŸ‡ºðŸ‡¸ US - New York #123" or "ðŸ‡ºðŸ‡¸ US - California, Los Angeles (123)"
get_pretty_server_name() {
    local server_name="$1"
    local script_dir="${2:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"

    # Get server info
    local info_output
    info_output=$("$script_dir/lazyvpn-get-server-info" "$server_name" 2>/dev/null)

    if [[ -z "$info_output" ]]; then
        # Fallback to plain name if info fetch fails
        echo "$server_name"
        return
    fi

    local country state city number provider services
    country=$(echo "$info_output" | grep "^country=" | cut -d= -f2)
    state=$(echo "$info_output" | grep "^state=" | cut -d= -f2)
    city=$(echo "$info_output" | grep "^city=" | cut -d= -f2)
    number=$(echo "$info_output" | grep "^number=" | cut -d= -f2)
    provider=$(echo "$info_output" | grep "^provider=" | cut -d= -f2)
    services=$(echo "$info_output" | grep "^services=" | cut -d= -f2)

    # Build pretty name
    local pretty_name=""
    local flag=""

    # Check if this is a Secure Core server (multi-hop)
    local is_secure_core=false
    local entry_country=""
    local exit_country=""
    if [[ ",$services," == *",securecore,"* ]]; then
        is_secure_core=true
        # For Secure Core servers:
        # - country field = ENTRY country (CH, IS, SE)
        # - Exit country is in city OR state field (whichever is the second component)
        entry_country="$country"

        # Exit country can be in city (if 3+ components) or state (if 2 components)
        if [[ -n "$city" ]]; then
            exit_country="$city"
        elif [[ -n "$state" ]]; then
            exit_country="$state"
        fi

        # Build dual flag for Secure Core
        if [[ -n "$entry_country" ]] && [[ -n "$exit_country" ]]; then
            flag="$(country_flag "$entry_country")â†’$(country_flag "$exit_country")"
        else
            # Fallback to single flag if parsing failed
            flag=$(country_flag "$country")
        fi
    else
        # Regular server - single flag
        if [[ -n "$country" ]] && [[ "$country" != "Unknown" ]]; then
            flag=$(country_flag "$country")
        else
            pretty_name="$server_name"
            return
        fi
    fi

    # Add state and/or city with smart formatting
    if [[ -n "$state" ]] && [[ -n "$city" ]]; then
        # Both state and city
        local expanded_country expanded_state expanded_city
        expanded_country=$(expand_country_name "$country")
        expanded_state=$(expand_location_name "$state")
        expanded_city=$(expand_location_name "$city")

        # Special case for Secure Core: show entryâ†’exit country names
        if [[ "$is_secure_core" == true ]]; then
            local exit_country_name
            exit_country_name=$(expand_country_name "$exit_country")
            pretty_name="$flag $expanded_country â†’ $exit_country_name"
        # Special case for DC (Washington DC is a city-state)
        elif [[ "$state" == "DC" ]] && { [[ "$city" == "Washington" ]] || [[ "$city" == "DC" ]]; }; then
            pretty_name="$flag $expanded_country - Washington DC"
        else
            # Regular state+city: "ðŸ‡ºðŸ‡¸ United States - California, Los Angeles"
            pretty_name="$flag $expanded_country - $expanded_state, $expanded_city"
        fi
    elif [[ -n "$state" ]]; then
        # Just state, no city
        local expanded_country expanded_state
        expanded_country=$(expand_country_name "$country")
        expanded_state=$(expand_location_name "$state")

        # Special case for Secure Core: state field contains exit country
        if [[ "$is_secure_core" == true ]]; then
            local exit_country_name
            exit_country_name=$(expand_country_name "$exit_country")
            pretty_name="$flag $expanded_country â†’ $exit_country_name"
        else
            # Regular: "ðŸ‡ºðŸ‡¸ United States - New York" or "ðŸ‡¸ðŸ‡ª Sweden - Stockholm"
            pretty_name="$flag $expanded_country - $expanded_state"
        fi
    elif [[ -n "$city" ]]; then
        # Just city/location: "ðŸ‡ºðŸ‡¸ United States - New York"
        local expanded_country expanded_city
        expanded_country=$(expand_country_name "$country")
        expanded_city=$(expand_location_name "$city")

        # Check if city looks like a US state code (2 uppercase letters)
        if [[ "$city" =~ ^[A-Z]{2}$ ]] && [[ "$country" == "US" ]]; then
            # It's a US state - format as "United States - State Name"
            pretty_name="$flag $expanded_country - $expanded_city"
        else
            # Regular city/location
            pretty_name="$flag $expanded_country - $expanded_city"
        fi
    else
        # No city or state: "ðŸ‡¸ðŸ‡ª Sweden"
        local expanded_country
        expanded_country=$(expand_country_name "$country")
        pretty_name="$flag $expanded_country"
    fi

    # Add server number with parentheses if available
    if [[ -n "$number" ]]; then
        pretty_name="$pretty_name ($number)"
    fi

    # Add feature emojis based on services
    # Use comma-separated matching to avoid substring false positives
    local feature_emojis=""
    if [[ -n "$services" ]]; then
        # P2P support
        if [[ ",$services," == *",p2p,"* ]]; then
            feature_emojis="${feature_emojis}ðŸ”„"
        fi
        # Tor support
        if [[ ",$services," == *",tor,"* ]]; then
            feature_emojis="${feature_emojis}ðŸ§…"
        fi
        # Secure Core
        if [[ ",$services," == *",securecore,"* ]]; then
            feature_emojis="${feature_emojis}ðŸ”’"
        fi
        # Streaming
        if [[ ",$services," == *",streaming,"* ]]; then
            feature_emojis="${feature_emojis}ðŸ“º"
        fi
        # Free tier
        if [[ ",$services," == *",free,"* ]]; then
            feature_emojis="${feature_emojis}ðŸ¤¡"
        fi
        # VPN Accelerator
        if [[ ",$services," == *",accelerator,"* ]]; then
            feature_emojis="${feature_emojis}ðŸš€"
        fi
        # NetShield Level 1 (malware blocking only)
        if [[ ",$services," == *",netshield1,"* ]]; then
            feature_emojis="${feature_emojis}ðŸ—¡ï¸"
        fi
        # NetShield Level 2 (malware + ad blocking)
        if [[ ",$services," == *",netshield2,"* ]]; then
            feature_emojis="${feature_emojis}âš”ï¸"
        fi
        # Moderate NAT (gaming optimized)
        if [[ ",$services," == *",moderatenat,"* ]]; then
            feature_emojis="${feature_emojis}ðŸŽ®"
        fi
    fi

    # Add feature emojis if any were found
    if [[ -n "$feature_emojis" ]]; then
        pretty_name="$pretty_name $feature_emojis"
    fi

    # Add provider if known
    if [[ -n "$provider" ]]; then
        pretty_name="$pretty_name â€¢ $provider"
    fi

    echo "$pretty_name"
}

# Generate standardized server filename from a config file
# Input: config file path, destination directory
# Output: standardized filename (without .conf extension)
# Example: "Proton-US-NY#123" or "Mullvad-SE-Stockholm#5"
generate_standard_server_name() {
    local config_file="$1"
    local dest_dir="$2"
    local original_name=$(basename "$config_file" .conf)

    # Parse config for endpoint
    local endpoint=$(grep -m1 "^Endpoint" "$config_file" | cut -d= -f2 | tr -d ' ')
    local server_ip=$(echo "$endpoint" | cut -d: -f1)

    # Detect provider
    local provider=""
    local dns=$(grep -m1 "^DNS" "$config_file" | cut -d= -f2 | tr -d ' ')

    # Provider detection (same logic as lazyvpn-get-server-info)
    case "$dns" in
        10.2.0.1) provider="Proton" ;;
        10.64.0.1|193.138.218.74) provider="Mullvad" ;;
        172.16.0.1) provider="IVPN" ;;
        10.0.0.241|10.0.0.242) provider="PIA" ;;
    esac

    # Also check endpoint and comments
    if [[ -z "$provider" ]]; then
        if [[ "$endpoint" =~ protonvpn\.com|protonvpn\.net ]] || grep -qi "protonvpn" "$config_file"; then
            provider="Proton"
        elif [[ "$endpoint" =~ mullvad\.net ]] || grep -qi "mullvad" "$config_file"; then
            provider="Mullvad"
        elif [[ "$endpoint" =~ ivpn\.net ]] || grep -qi "ivpn" "$config_file"; then
            provider="IVPN"
        elif [[ "$endpoint" =~ privateinternetaccess\.com ]]; then
            provider="PIA"
        elif [[ "$endpoint" =~ nordvpn\.com ]] || grep -qi "nordvpn" "$config_file"; then
            provider="Nord"
        elif [[ "$endpoint" =~ surfshark\.com ]] || grep -qi "surfshark" "$config_file"; then
            provider="Surf"
        fi
    fi

    # Try to parse location from original filename
    local parse_name="$original_name"
    # Strip provider prefix
    parse_name=$(echo "$parse_name" | sed -E 's/^(proton|mullvad|ivpn|pia|nord|surf|wg|vpn|server)-//i')

    local country="" state="" city="" number=""

    # Try to extract location from filename
    if [[ "$parse_name" =~ ^([A-Z]{2})[-_]([A-Z]{2})[-_]([A-Za-z]+)[-_#]([0-9]+) ]]; then
        # US-CA-LosAngeles#123
        country="${BASH_REMATCH[1]}"
        state="${BASH_REMATCH[2]}"
        city="${BASH_REMATCH[3]}"
        number="${BASH_REMATCH[4]}"
    elif [[ "$parse_name" =~ ^([A-Z]{2,})[-_]([A-Za-z]+)[-_#]([0-9]+) ]]; then
        # SE-Stockholm-130 or US-DC-30
        country="${BASH_REMATCH[1]}"
        city="${BASH_REMATCH[2]}"
        number="${BASH_REMATCH[3]}"
    elif [[ "$parse_name" =~ ^([A-Z]{2,})[-_]([0-9]+) ]]; then
        # SE-130 or US-30
        country="${BASH_REMATCH[1]}"
        number="${BASH_REMATCH[2]}"
    elif [[ "$parse_name" =~ ^([A-Z]{2,})#([0-9]+) ]]; then
        # SE#130
        country="${BASH_REMATCH[1]}"
        number="${BASH_REMATCH[2]}"
    fi

    # Filter out tier keywords from location fields (they're features, not locations)
    if [[ "$city" =~ ^(FREE|PLUS|PREMIUM|PRO)$ ]]; then
        city=""
    fi
    if [[ "$state" =~ ^(FREE|PLUS|PREMIUM|PRO)$ ]]; then
        state=""
    fi

    # Use IP geolocation to fill in missing location info (city/state)
    # Always lookup if we have an IP and are missing state or city
    if [[ -n "$server_ip" ]] && { [[ -z "$state" ]] || [[ -z "$city" ]]; }; then
        # Use temporary geolocation lookup (no cache for this one-time operation)
        local response
        response=$(curl -s --connect-timeout 5 --max-time 10 \
            "http://ip-api.com/json/${server_ip}?fields=status,countryCode,region,city" 2>/dev/null)

        if [[ $? -eq 0 ]] && [[ -n "$response" ]]; then
            local status=$(echo "$response" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
            if [[ "$status" == "success" ]]; then
                local geo_country=$(echo "$response" | grep -o '"countryCode":"[^"]*"' | cut -d'"' -f4)
                local geo_city=$(echo "$response" | grep -o '"city":"[^"]*"' | cut -d'"' -f4)
                local geo_region=$(echo "$response" | grep -o '"region":"[^"]*"' | cut -d'"' -f4)

                # Use geolocation country if we don't have one from filename
                if [[ -z "$country" ]] && [[ -n "$geo_country" ]]; then
                    country="$geo_country"
                fi

                # Fill in state if missing (for US/CA, use region code)
                if [[ -z "$state" ]] && [[ -n "$geo_region" ]]; then
                    if [[ "$country" == "US" ]] || [[ "$country" == "CA" ]] || [[ "$country" == "SE" ]]; then
                        state="$geo_region"
                    fi
                fi

                # Fill in city if missing (clean it for filename)
                if [[ -z "$city" ]] && [[ -n "$geo_city" ]]; then
                    city=$(echo "$geo_city" | tr -d ' ')
                fi
            fi
        fi
    fi

    # Detect features from filename and config
    local features=""
    if [[ "$original_name" =~ [Pp]2[Pp] ]] || grep -qiw "p2p" "$config_file" 2>/dev/null; then
        features="${features:+$features-}P2P"
    fi
    if [[ "$original_name" =~ -[Tt]or- ]] || [[ "$original_name" =~ -[Tt]or$ ]] || [[ "$original_name" =~ ^[Tt]or- ]] || grep -qiE '\btor\b' "$config_file" 2>/dev/null; then
        features="${features:+$features-}Tor"
    fi
    if [[ "$original_name" =~ [Ss]ecure[_-]?[Cc]ore ]] || grep -qiE 'secure.core|securecore' "$config_file" 2>/dev/null; then
        features="${features:+$features-}SC"
    fi
    if [[ "$original_name" =~ [Ss]treaming ]] || grep -qiw "streaming" "$config_file" 2>/dev/null; then
        features="${features:+$features-}Stream"
    fi

    # Generate number if missing (find next available)
    if [[ -z "$number" ]] && [[ -n "$dest_dir" ]]; then
        # Find existing servers with same location
        local max_num=0
        local search_pattern="${provider:+$provider-}${country}${state:+-$state}${city:+-$city}${features:+-$features}#"

        shopt -s nullglob
        for existing in "$dest_dir"/*.conf; do
            local existing_base=$(basename "$existing" .conf)
            if [[ "$existing_base" =~ ^${search_pattern}([0-9]+)$ ]]; then
                local num="${BASH_REMATCH[1]}"
                if [[ $num -gt $max_num ]]; then
                    max_num=$num
                fi
            fi
        done
        shopt -u nullglob
        number=$((max_num + 1))
    fi

    # Build standardized name
    local std_name=""

    # Add provider prefix
    if [[ -n "$provider" ]]; then
        std_name="$provider"
    fi

    # Add country
    if [[ -n "$country" ]]; then
        std_name="${std_name:+$std_name-}${country}"
    else
        # Fallback: keep original name if we couldn't determine location
        echo "$original_name"
        return
    fi

    # Add state (US only)
    if [[ -n "$state" ]]; then
        std_name="${std_name}-${state}"
    fi

    # Add city
    if [[ -n "$city" ]]; then
        std_name="${std_name}-${city}"
    fi

    # Add features
    if [[ -n "$features" ]]; then
        std_name="${std_name}-${features}"
    fi

    # Add number
    if [[ -n "$number" ]]; then
        std_name="${std_name}#${number}"
    fi

    echo "$std_name"
}
