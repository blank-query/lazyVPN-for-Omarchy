#!/bin/bash

# Disconnect from VPN (systemd-networkd version)

# Source common functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lazyvpn-common" || exit 1
# shellcheck source=./lazyvpn-common

CONFIG_DIR="$HOME/.config/lazyvpn"
CONFIG_FILE="$CONFIG_DIR/config"

# Load connection name from config
load_config "$CONFIG_FILE"
CONN_NAME="${CONNECTION_NAME:-wg0}"

# Validate CONNECTION_NAME
if [[ ! "$CONN_NAME" =~ ^[a-zA-Z0-9._-]+$ ]]; then
  error "Invalid CONNECTION_NAME in config"
fi

# Check if connection is active
if ! is_connected "$CONN_NAME"; then
  info "Not connected to any LazyVPN server"
  exit 0
fi

# Show current public IP before disconnecting
echo ""
info "Checking current public IP..."
BEFORE_IP=$(curl -s --connect-timeout 3 --max-time 5 https://api.ipify.org 2>/dev/null)
if [[ -n "$BEFORE_IP" ]]; then
  info "Current IP: $BEFORE_IP (via VPN)"
else
  info "Current IP: Unable to retrieve"
fi
echo ""

debug_log connection "Disconnecting interface: $CONN_NAME"
info "Disconnecting from VPN..."

# Bring down the interface
sudo networkctl down "$CONN_NAME"

# Delete the .netdev and .network files
# Remove systemd-networkd config files using secure file helper
NETDEV_FILE="/etc/systemd/network/99-${CONN_NAME}.netdev"
NETWORK_FILE="/etc/systemd/network/99-${CONN_NAME}.network"

if [ -f "$NETDEV_FILE" ] || [ -f "$NETWORK_FILE" ]; then
    sudo "$SCRIPT_DIR/lazyvpn-file-helper" remove "$CONN_NAME" || {
        # Fallback for backward compatibility if file helper not found
        secure_delete --sudo "$NETDEV_FILE" "$NETWORK_FILE"
    }
fi

# Clean up routes (VPN endpoint host route might persist)
# The default route through VPN will be removed when interface goes down
# Get VPN endpoint from netdev file before removing it
if ip route show | grep -q "via.*$CONN_NAME"; then
    info "Cleaning up VPN routes..."
    # Remove routes through VPN interface
    sudo ip route del default dev "$CONN_NAME" 2>/dev/null || true
fi

# Restart systemd-networkd to apply changes
info "Restarting systemd-networkd..."
sudo systemctl restart systemd-networkd

echo ""
info "Verifying disconnection..."

# Load current config to check killswitch auto-disable setting
load_config "$CONFIG_FILE"

# Check if killswitch is active (by checking for the DROP rule)
if [[ "${KILLSWITCH:-false}" == "true" ]] && sudo iptables -C LAZYVPN_OUT -j DROP &>/dev/null; then
  debug_log connection "Killswitch active on disconnect, mode=${KILLSWITCH_AUTO_DISABLE:-true}"
  case "${KILLSWITCH_AUTO_DISABLE:-true}" in
    true)
      # AUTO: automatically disable killswitch
      "$SCRIPT_DIR/lazyvpn-disable-killswitch"
      notify "Killswitch automatically disabled."
      ;;
    false)
      # PROMPT: ask user what to do
      echo ""
      echo "╔════════════════════════════════════════════════════════╗"
      echo "║ Killswitch Active                                      ║"
      echo "╠════════════════════════════════════════════════════════╣"
      echo "║ The killswitch is currently blocking all traffic.      ║"
      echo "║                                                        ║"
      echo "║ Do you want to disable the killswitch?                 ║"
      echo "║                                                        ║"
      echo "║   YES - Restore normal internet access                 ║"
      echo "║   NO  - Keep killswitch active (blocks all internet    ║"
      echo "║         until you reconnect to any VPN server)         ║"
      echo "╚════════════════════════════════════════════════════════╝"
      echo ""
      read -r -p "Disable killswitch? [Y/n]: " response
      if [[ "$response" =~ ^[Nn]$ ]]; then
        notify "Killswitch remains active.\nInternet is blocked until you reconnect to VPN."
        info "Killswitch remains active"
        info "Internet is blocked - reconnect to any VPN server to restore access"
      else
        "$SCRIPT_DIR/lazyvpn-disable-killswitch"
        notify "Killswitch disabled."
        info "Killswitch disabled"
      fi
      ;;
    never)
      # NEVER: keep killswitch active, notify user
      notify "Killswitch remains active.\nInternet is blocked until you reconnect to VPN."
      info "Killswitch remains active (set to NEVER mode)"
      info "Internet is blocked - reconnect to any VPN server to restore access"
      ;;
  esac
fi

# Verify disconnection by checking IP
DISCONNECT_FAILED=false
FAILURE_REASON=""

# Check if killswitch is still blocking
KILLSWITCH_BLOCKING=false
if sudo iptables -C LAZYVPN_OUT -j DROP &>/dev/null; then
  KILLSWITCH_BLOCKING=true
fi

if [[ "$KILLSWITCH_BLOCKING" == "true" ]]; then
  # Killswitch is active - we should NOT be able to get an IP
  echo ""
  info "Killswitch is active - verifying traffic is blocked..."
  sleep 2

  AFTER_IP=$(curl -s --connect-timeout 3 --max-time 5 https://api.ipify.org 2>/dev/null)

  if [[ -n "$AFTER_IP" ]]; then
    # We got an IP when killswitch should be blocking - FAILURE
    DISCONNECT_FAILED=true
    FAILURE_REASON="Killswitch enabled but traffic is not blocked (IP: $AFTER_IP)"
  else
    # No IP - killswitch is working correctly
    info "✓ Killswitch verification passed - traffic blocked"
  fi
else
  # Killswitch is disabled - IP should have changed
  echo ""
  info "Checking public IP..."
  sleep 2

  AFTER_IP=$(curl -s --connect-timeout 5 --max-time 10 https://api.ipify.org 2>/dev/null)

  # Get stored real IP to detect phantom connections
  REAL_PUBLIC_IP="${REAL_PUBLIC_IP:-}"

  if [[ -z "$AFTER_IP" ]]; then
    # Can't get IP when we should be able to
    DISCONNECT_FAILED=true
    FAILURE_REASON="Unable to retrieve public IP after disconnect"
  elif [[ "$AFTER_IP" == "$BEFORE_IP" ]]; then
    # IP didn't change - but check if VPN was already dead (phantom connection)
    if [[ -n "$REAL_PUBLIC_IP" ]] && [[ "$BEFORE_IP" == "$REAL_PUBLIC_IP" ]]; then
      # The "VPN IP" was actually our real IP - VPN connection had already failed
      info "Public IP: $AFTER_IP"
      info "✓ VPN connection was already inactive - cleanup complete"
    else
      # IP didn't change and doesn't match stored real IP - still on VPN
      DISCONNECT_FAILED=true
      FAILURE_REASON="Still showing VPN IP (IP unchanged: $AFTER_IP)"
    fi
  else
    # IP changed - successful disconnect
    info "Public IP: $AFTER_IP"
    info "✓ IP verification passed - disconnected from VPN"
  fi
fi

# Handle disconnection failure
if [[ "$DISCONNECT_FAILED" == "true" ]]; then
  echo ""
  echo "Error: Disconnection failed - $FAILURE_REASON"

  echo ""
  read -r -p "Retry disconnection? [Y/n] " retry_response
  if [[ "$retry_response" =~ ^[Nn]$ ]]; then
    notify "Disconnection verification failed."
    exit 1
  else
    # User wants to retry - re-run this script
    echo ""
    info "Retrying disconnection..."
    exec "$0"
  fi
fi

# All verification passed
debug_log connection "Disconnection verified successfully"

# Clear stored IPs for privacy
atomic_config_update "REAL_PUBLIC_IP" "" "$CONFIG_FILE"
atomic_config_update "LAST_PUBLIC_IP" "" "$CONFIG_FILE"
atomic_config_update "LAST_CONNECTED_SERVER" "" "$CONFIG_FILE"

echo ""
info "Successfully disconnected"
